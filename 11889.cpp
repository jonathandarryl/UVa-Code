#include <stdio.h>
#include <iostream>
#include <cstdlib>
#include <cmath>
#include <string>
#include <cstring>
#include <vector>
#include <map>
#include <stack>
#include <queue>
#include <deque>
#include <algorithm>
#include <set>
#include <bitset>
using namespace std;

typedef long long ll;
typedef pair<int,int> ii;
typedef vector<ii> vii;
typedef vector<int> vi;

#define fi first
#define se second
#define INF 1000000000
#define INFLL 1000000000000000000LL
#define pb push_back
#define TC(tc) while(tc--)
#define reset(a,b) memset(a,b,sizeof(a))

ll _sieve_size;
vi primes;
bitset<10000010> bs;   // 10^7 should be enough for most cases
void sieve(ll upperbound) {          // create list of primes in [0..upperbound]
  _sieve_size = upperbound + 1;                   // add 1 to include upperbound
  bs.set();                                                 // set all bits to 1
  bs[0] = bs[1] = 0;                                     // except index 0 and 1
  for (ll i = 2; i <= _sieve_size; i++) if (bs[i]) {
    // cross out multiples of i starting from i * i!
    for (ll j = i * i; j <= _sieve_size; j += i) bs[j] = 0;
    primes.push_back((int)i);  // also add this vector containing list of primes
} }

vi primeFactors(ll N) {   // remember: vi is vector of integers, ll is long long
  vi factors;                    // vi `primes' (generated by sieve) is optional
  ll PF_idx = 0, PF = primes[PF_idx];     // using PF = 2, 3, 4, ..., is also ok
  while (N != 1 && (PF * PF <= N)) {   // stop at sqrt(N), but N can get smaller
    while (N % PF == 0) { N /= PF; factors.push_back(PF); }    // remove this PF
    PF = primes[++PF_idx];                              // only consider primes!
  }
  if (N != 1) factors.push_back(N);     // special case if N is actually a prime
  return factors;         // if pf exceeds 32-bit integer, you have to change vi
}

int main(void){
    int tc;
    sieve(1000000);
    scanf("%d",&tc);
    map<int,int> mA,mB;
    TC(tc){
        int a,b;
        scanf("%d%d",&a,&b);
        if(a>b) printf("NO SOLUTION\n");
        else if(a==b) printf("1\n");
        else{
            mA.clear();
            mB.clear();
            vi A = primeFactors(a);
            vi B = primeFactors(b);
            for(int i=0;i<A.size();i++)
                mA[A[i]]++;
            for(int i=0;i<B.size();i++)
                mB[B[i]]++;
            bool valid = true;
            for(map<int,int>::iterator it = mA.begin();it!=mA.end();it++){
               // printf("faktor:%d^ %d\n",it->first,it->second);
                if(mB[it->first]<it->second) {valid = false;break;}

            }
            /*
            for(map<int,int>::iterator it = mB.begin();it!=mB.end();it++){
                printf("faktor:%d^ %d\n",it->first,it->second);
            }*/
            ll total = 1;
            if(valid)
                for(map<int,int>::iterator it = mB.begin();it!=mB.end();it++){
                    if(it->second > mA[it->first]){
                        //printf("%d %d %d\n",it->first,it->second, mA[it->second]);
                        for(int i=0;i<it->second;i++)
                            total*=it->first;
                        //total*= pow((double)it->first, (double)it->second);
                       // printf("total = %lld\n",total);
                    }
                }
            if(total > b || !valid)printf("NO SOLUTION\n");
            else printf("%lld\n",total);

        }


    }

    return 0;
}
